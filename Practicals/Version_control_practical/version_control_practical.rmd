---
title: "Version Control tutorial"
author: "David Lawrence"
date: "2022-09-12"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Vocab review

Make sure you are familiar with these terms!

* Diff
* Hashing
* Lock / Locking
* Repository (repo)
* Revision
* Changelog
* revert

## Cloning a repo

You've probably already done this but:

```
# Clone a repo
git clone https://github.com/University-of-Adelaide-Bx-Masters/BIOTECH-7005-BIOINF-3000
```

## Your repo

When you clone a repo - you make a local copy of the whole version control database (history, deleted files etc)

Remember this is your own personal repository, you can do whatever you like! You are not modifying the GitHub repo unless you send your changes up, and you don't have permission to do that, so don't worry!

Look in the .git directory. and compare the size with the total repo:

```
du -sh .git
du -sh
```

The .git directory contains the diffs.

The "normal files" in the directory are created by git by applying a series of changes (diffs) 

You're looking at the latest copy - ie files made by applying all of the changes (diffs)

## Changelog (history)

Examine the changelog by running

```
git log
```

This shows commits (most recent first) - an example:

```
commit 97aba47a9e8a5db9fd0960df025fb11eeb20138f
Author: Dave Lawrence <davmlaw@gmail.com>
Date:   Tue Sep 6 03:10:15 2022 +0930

    Fix main README link to coding comments
```

At the top is a commit hash. This is the label for this change.
There's also the user, date and a change comment.

There are many entries - you're looking at a change log, a log of changes (diffs) applied in a sequence, where each is labelled with a hash.

To see this, compare the commit hash BEFORE a change with the pick a commit hash of a change, eg:

```
# git diff (previous commit hash) (commit hash)
git diff 141d48db593f24783169062b1e94c4259bacfaeb 97aba47a9e8a5db9fd0960df025fb11eeb20138f
```

You can also look across multiple commits - eg try diffing across 2, 3 or 4 commits

## HEAD - the latest commit

It's changed now, but when writing this the top commit was: 

```
commit f6cec9c27eea6ef854f754f1adbe3c3310cb708d (HEAD -> master, origin/master, origin/HEAD)
Author: dadelson <david.adelson@adelaide.edu.au>
Date:   Mon Sep 12 12:33:39 2022 +0930

    updated assignment 4
```

This commit has some extra stuff after it. These are special labels that are automatically created.

**HEAD** - is the end of a branch, ie the latest commit
**master (or main)** - is the default name of a branch (we'll come back to this)

Copy/paste the latest commit into git diff

```
git diff paste_latest_hash_here HEAD
```

This compares the last commit with head. Since they are different labels for the same commit, there is no difference and nothing is displayed.

You use HEAD so often that it is the default argument in Git. Ie if you don't specify a commit, you are assumed to be comparing it to Git. Ie:

```
git diff paste_latest_hash_here HEAD
git diff paste_latest_hash_here # Implicitly comparing to HEAD
```

Find an earlier commit (eg 2nd to last commit) and run the above commands comparing it to HEAD explicitly then implicitly

## Moving through history

Git stores (in .git) all of the changes ever applied to the files in the repo. The "normal files" (under management of Git) are created by git by replying changes.

To move through history - you want to replace the current files (generated by running all diffs up till the latest, ie HEAD) with ones that only have the changes done up until a certain time (commit)

So - to see a snapshot of how the repository looked at a commit - you can "check out" that commit:

```
git checkout 141d48db593f24783169062b1e94c4259bacfaeb
```

All files (under management in the repo) are as they were at that time.

```
# You can copy this version of the file somewhere else
cp README.md /tmp
```

If you run "git log" now - you can see that the final commit is not pointing to "master" anymore.

To get back to the latest commit, run:

```
git checkout master
```

You now have 2 copies of the file - and can compare them

```
# Normal diff, not git diff
diff /tmp/README.md README.md
```

## Restoring deleted files

```
git checkout master  # Just in case we forgot where we are
# Delete the README file
rm README.md
```

Now run:

```
git diff
```

```
diff --git a/README.md b/README.md
deleted file mode 100644
index b9c9865..0000000
--- a/README.md
+++ /dev/null
@@ -1,138 +0,0 @@
-* TOC
-{:toc}
-
-## Biotech 7005/Bioinf 3000: Frontiers of Biotechnology: Bioinformatics and Systems Modelling
-{:.no_toc}
-
-Semester 2 2022
-
-Coordinator:
```

The file has been deleted (all rows with "-" in front)

Remember you can look for help - Google [git restore deleted file](https://stackoverflow.com/a/21307473)

So you can restore the file via:

```
git checkout README.md
```

## Something scary

```
# Make sure you are in the right directory!
# Then run:
rm -rf *
```

Whoops! Now Google for "git restore all deleted files" - the top result is from [stack overflow](https://stackoverflow.com/a/26892936)

You should be able to restore everything via:

```
git ls-files -z -d | xargs -0 git checkout --
```

Note: I didn't know how to do this before looking on Stack Overflow.

## Modifying a file

* Go and edit the README.md file and delete lines, add lines, just totally trash it
* To see what you changed (can you remember?)

```git diff``

* Imagine if you had to restore this by manually undoing those changes?
* Revert all changes via:

```git checkout README.md```

## Committing a file

* Modify the README.md and add a section called "students" and add your name

Or, modify the file in any other way you want.

Run

```
git diff
```

To see the lines you added.

Commit the changes - the "-m" adds a message. You should write good messages!

```
git add README.md
git commit -m "Added student section"
```

Now run ```git log```

You can see we're out of sync with "origin/master" (which is the remote - ie GitHub)

## Blame Game

Run

```git blame README.md```

Scroll through the file until you get to the student section. You should see your own name, indicating you were responsible for the last changes to this line. They're onto you!

## Destroying commits

The latest change was put into our repository. We haven't "pushed" it up to GitHub yet, so it's only here on our local repo

If it's not secret information (or embarassing) you should probably just fix things like this via a "soft" restore:

* Restore the file from before the change
* Check in that file over the top of the change

This will leave 2 commits, the change and undoing the change.

But - you can delete the commits - Googling for: 

[git delete unpushed commit](https://stackoverflow.com/a/3197432)

Says you can do a hard reset via:

```
# This is ok on this test repo but
# DANGER: things like "--force" and "--hard" are some of the few ways to permanently lose code in Git
git reset --hard HEAD~1
```

Note: As this is so dangerous I look it up on Stack overflow to make sure I got the command exactly right

## Emergency maneuvers

You could have also done it this way:

![](https://imgs.xkcd.com/comics/git_2x.png)
